{"version":3,"file":"vue-wc-wrapper.global.js","sources":["../src/utils.js","../src/index.js"],"sourcesContent":["const camelizeRE = /-(\\w)/g\nexport const camelize = str => {\n  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : '')\n}\n\nconst hyphenateRE = /\\B([A-Z])/g\nexport const hyphenate = str => {\n  return str.replace(hyphenateRE, '-$1').toLowerCase()\n}\n\nexport function getInitialProps (propsList) {\n  const res = {}\n  propsList.forEach(key => {\n    res[key] = undefined\n  })\n  return res\n}\n\nexport function injectHook (options, key, hook) {\n  options[key] = [].concat(options[key] || [])\n  options[key].unshift(hook)\n}\n\nexport function callHooks (vm, hook) {\n  if (vm) {\n    const hooks = vm.$options[hook] || []\n    hooks.forEach(hook => {\n      hook.call(vm)\n    })\n  }\n}\n\nexport function createCustomEvent (name, args) {\n  return new CustomEvent(name, {\n    bubbles: false,\n    cancelable: false,\n    detail: args\n  })\n}\n\nconst isBoolean = val => /function Boolean/.test(String(val))\nconst isNumber = val => /function Number/.test(String(val))\n\nexport function convertAttributeValue (value, name, { type } = {}) {\n  if (isBoolean(type)) {\n    if (value === 'true' || value === 'false') {\n      return value === 'true'\n    }\n    if (value === '' || value === name) {\n      return true\n    }\n    return value != null\n  } else if (isNumber(type)) {\n    const parsed = parseFloat(value, 10)\n    return isNaN(parsed) ? value : parsed\n  } else {\n    return value\n  }\n}\n\nexport function toVNodes (h, children) {\n  const res = []\n  for (let i = 0, l = children.length; i < l; i++) {\n    res.push(toVNode(h, children[i]))\n  }\n  return res\n}\n\nfunction toVNode (h, node) {\n  if (node.nodeType === 3) {\n    return node.data.trim() ? node.data : null\n  } else if (node.nodeType === 1) {\n    const data = {\n      attrs: getAttributes(node),\n      domProps: {\n        innerHTML: node.innerHTML\n      }\n    }\n    if (data.attrs.slot) {\n      data.slot = data.attrs.slot\n      delete data.attrs.slot\n    }\n    return h(node.tagName, data)\n  } else {\n    return null\n  }\n}\n\nfunction getAttributes (node) {\n  const res = {}\n  for (let i = 0, l = node.attributes.length; i < l; i++) {\n    const attr = node.attributes[i]\n    res[attr.nodeName] = attr.nodeValue\n  }\n  return res\n}\n","import {\n  toVNodes,\n  camelize,\n  hyphenate,\n  callHooks,\n  injectHook,\n  getInitialProps,\n  createCustomEvent,\n  convertAttributeValue\n} from './utils.js'\n\nexport default function wrap(Vue, Component) {\n  const isAsync = typeof Component === 'function' && !Component.cid\n  let isInitialized = false\n  let hyphenatedPropsList\n  let camelizedPropsList\n  let camelizedPropsMap\n\n  function initialize(Component) {\n    if (isInitialized) return\n\n    const options =\n      typeof Component === 'function' ? Component.options : Component\n\n    // extract props info\n    const propsList = Array.isArray(options.props)\n      ? options.props\n      : Object.keys(options.props || {})\n    hyphenatedPropsList = propsList.map(hyphenate)\n    camelizedPropsList = propsList.map(camelize)\n    const originalPropsAsObject = Array.isArray(options.props)\n      ? {}\n      : options.props || {}\n    camelizedPropsMap = camelizedPropsList.reduce((map, key, i) => {\n      map[key] = originalPropsAsObject[propsList[i]]\n      return map\n    }, {})\n\n    // proxy $emit to native DOM events\n    injectHook(options, 'beforeCreate', function () {\n      const emit = this.$emit\n      this.$emit = (name, ...args) => {\n        this.$root.$options.customElement.dispatchEvent(\n          createCustomEvent(name, args)\n        )\n        return emit.call(this, name, ...args)\n      }\n    })\n\n    injectHook(options, 'created', function () {\n      // sync default props values to wrapper on created\n      camelizedPropsList.forEach((key) => {\n        this.$root.props[key] = this[key]\n      })\n    })\n\n    // proxy props as Element properties\n    camelizedPropsList.forEach((key) => {\n      Object.defineProperty(CustomElement.prototype, key, {\n        get() {\n          return this._wrapper.props[key]\n        },\n        set(newVal) {\n          this._wrapper.props[key] = newVal\n        },\n        enumerable: false,\n        configurable: true\n      })\n    })\n\n    isInitialized = true\n  }\n\n  function syncAttribute(el, key) {\n    const camelized = camelize(key)\n    const value = el.hasAttribute(key) ? el.getAttribute(key) : undefined\n    el._wrapper.props[camelized] = convertAttributeValue(\n      value,\n      key,\n      camelizedPropsMap[camelized]\n    )\n  }\n\n  class CustomElement extends HTMLElement {\n    constructor() {\n      const self = super()\n      self.attachShadow({ mode: 'open' })\n\n      const wrapper = (self._wrapper = new Vue({\n        name: 'shadow-root',\n        customElement: self,\n        shadowRoot: self.shadowRoot,\n        data() {\n          return {\n            props: {},\n            slotChildren: [],\n            ShadyDOMSlotsHack_slotsPassedToWrapper: false,\n            ShadyDOMSlotsHack_deregisterSetIntervalListener: null\n          }\n        },\n        render(h) {\n          return h(\n            Component,\n            {\n              ref: 'inner',\n              props: this.props\n            },\n            this.slotChildren\n          )\n        }\n      }))\n\n      if (window.ShadyDOM) {\n        // MutationObserver does not work inside shadowRoot when polyfilled with ShadyDOM\n        // this makes slot changes go unrecognized by our usage of MutationObserver\n        // https://github.com/webcomponents/polyfills/issues/81\n\n        // ShadyDOM has a function called ShadyDOM.childrenObserver but it doesn't do the job very thoroughly, as it\n        // cannot recognize changes in slots when the slot count hasn't changed, and seemingly doesn't recognized removal of elements (https://github.com/webcomponents/polyfills/issues/82)\n        // .. what it can do for us however, is to observe whether slots are ever added.\n        // once a slot is added, we'll apply the hack to this wrapper.\n        // if slots are never used, we're saving ourselves some performance cost.\n        window.ShadyDOM.observeChildren(this, () => {\n          if (!wrapper.ShadyDOMSlotsHack_slotsPassedToWrapper) {\n            wrapper.ShadyDOMSlotsHack_slotsPassedToWrapper = true\n          }\n        })\n\n        // Here is the ugly fix to work around the core issue, basically setInterval, but shared across all vue wc wrappers for performance\n        // we preserve the original MutationObserver code further down, because it observes all other changes for us.\n        window.ShadyDOMSlotsHack_setInterval =\n          window.ShadyDOMSlotsHack_setInterval ||\n          // eslint-disable-next-line no-extra-parens\n          new (function () {\n            this.listeners = []\n\n            this.add = (handler) => {\n              const id = Math.floor(Math.random() * 1000000)\n              this.listeners.push({\n                handler,\n                id\n              })\n\n              if (this.listeners.length === 1) {\n                // first entry added, start setInterval\n                this.start()\n              }\n              return id\n            }\n\n            this.remove = (idToRemove) => {\n              this.listeners.splice(\n                this.listeners.findIndex(({ id }) => id === idToRemove),\n                1\n              )\n\n              if (this.listeners.length === 0) {\n                // no entries left, stop setInterval\n                this.stop()\n              }\n            }\n\n            this.start = () => {\n              if (this.intervalId === undefined || this.intervalId === null) {\n                this.intervalId = window.setInterval(() => {\n                  this.listeners.forEach(({ handler }) => handler())\n                }, 100)\n              }\n            }\n\n            this.stop = () => {\n              if (this.intervalId) {\n                window.clearInterval(this.intervalId)\n                this.intervalId = null\n              }\n            }\n          })()\n\n        const id = window.ShadyDOMSlotsHack_setInterval.add(() => {\n          if (wrapper.ShadyDOMSlotsHack_slotsPassedToWrapper) {\n            // slots were added to the wrapper at some point, so update children at every interval\n            this.updateSlotChildren()\n          }\n        })\n\n        wrapper.ShadyDOMSlotsHack_deregisterSetIntervalListener = () =>\n          window.ShadyDOMSlotsHack_setInterval.remove(id)\n      }\n\n      // Use MutationObserver to react to future attribute & slot content change\n      const observer = new MutationObserver((mutations) => {\n        let hasChildrenChange = false\n        for (let i = 0; i < mutations.length; i++) {\n          const m = mutations[i]\n          if (isInitialized && m.type === 'attributes' && m.target === self) {\n            syncAttribute(self, m.attributeName)\n          } else {\n            hasChildrenChange = true\n          }\n        }\n        if (hasChildrenChange) {\n          this.updateSlotChildren()\n        }\n      })\n      observer.observe(self, {\n        childList: true,\n        subtree: true,\n        characterData: true,\n        attributes: true\n      })\n    }\n\n    get vueComponent() {\n      return this._wrapper.$refs.inner\n    }\n\n    updateSlotChildren() {\n      this._wrapper.slotChildren = Object.freeze(\n        toVNodes(this._wrapper.$createElement, this.childNodes)\n      )\n\n      if (this._wrapper.slotChildren.length === 0) {\n        // no slots present, revert the shadyDOM hack (if present)\n        this._wrapper.ShadyDOMSlotsHack_slotsPassedToWrapper = false\n      }\n    }\n\n    async connectedCallback() {\n      const wrapper = this._wrapper\n\n      // TODO: Vue's router will be instantiated immediately, before the router\n      // in `mover-app` has finished transitioning URLs, making the Vue router\n      // resolve the wrong URL. Wait one micro-task to allow `mover-app`'s\n      // router to finish transitioning.\n      await Promise.resolve()\n\n      if (!wrapper._isMounted) {\n        // initialize attributes\n        const syncInitialAttributes = () => {\n          wrapper.props = getInitialProps(camelizedPropsList)\n          hyphenatedPropsList.forEach((key) => {\n            syncAttribute(this, key)\n          })\n        }\n\n        if (isInitialized) {\n          syncInitialAttributes()\n        } else {\n          // async & unresolved\n          Component().then((resolved) => {\n            if (\n              resolved.__esModule ||\n              resolved[Symbol.toStringTag] === 'Module'\n            ) {\n              resolved = resolved.default\n            }\n            initialize(resolved)\n            syncInitialAttributes()\n          })\n        }\n        // initialize children\n        this.updateSlotChildren()\n\n        // doing this will let us access the shadow root via `this.$root.$el.getRootNode()`\n        // inside of the mounted hook, which is important for copying global styles to the shadow dom.\n        const tempContainer = document.createElement('div')\n        this.shadowRoot.appendChild(tempContainer)\n\n        // tempContainer will be completely rewritten\n        wrapper.$mount(tempContainer)\n      } else {\n        callHooks(this.vueComponent, 'activated')\n      }\n    }\n\n    disconnectedCallback() {\n      if (\n        this._wrapper &&\n        this._wrapper.ShadyDOMSlotsHack_deregisterSetIntervalListener\n      ) {\n        this._wrapper.ShadyDOMSlotsHack_deregisterSetIntervalListener()\n      }\n\n      callHooks(this.vueComponent, 'deactivated')\n    }\n  }\n\n  if (!isAsync) {\n    initialize(Component)\n  }\n\n  return CustomElement\n}\n"],"names":["camelizeRE","camelize","str","replace","_","c","toUpperCase","hyphenateRE","hyphenate","toLowerCase","injectHook","options","key","hook","concat","unshift","callHooks","vm","$options","forEach","call","createCustomEvent","name","args","CustomEvent","bubbles","cancelable","detail","isBoolean","val","test","String","isNumber","toVNode","h","node","nodeType","data","trim","attrs","getAttributes","domProps","innerHTML","slot","tagName","res","i","l","attributes","length","attr","nodeName","nodeValue","Vue","Component","hyphenatedPropsList","camelizedPropsList","camelizedPropsMap","isAsync","cid","isInitialized","initialize","propsList","Array","isArray","props","Object","keys","map","originalPropsAsObject","reduce","emit","this","$emit","_this","$root","customElement","dispatchEvent","_this2","defineProperty","CustomElement","prototype","get","_wrapper","set","newVal","enumerable","configurable","syncAttribute","el","camelized","value","hasAttribute","getAttribute","undefined","type","parsed","parseFloat","isNaN","convertAttributeValue","self","attachShadow","mode","wrapper","shadowRoot","slotChildren","ShadyDOMSlotsHack_slotsPassedToWrapper","ShadyDOMSlotsHack_deregisterSetIntervalListener","render","ref","window","ShadyDOM","observeChildren","ShadyDOMSlotsHack_setInterval","listeners","add","handler","id","Math","floor","random","_this4","push","start","remove","idToRemove","splice","findIndex","stop","intervalId","setInterval","clearInterval","updateSlotChildren","MutationObserver","mutations","hasChildrenChange","m","target","attributeName","observe","childList","subtree","characterData","freeze","children","toVNodes","$createElement","childNodes","Promise","resolve","_isMounted","vueComponent","syncInitialAttributes","_this5","then","resolved","__esModule","Symbol","toStringTag","default","tempContainer","document","createElement","appendChild","$mount","$refs","inner","HTMLElement"],"mappings":"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"}